package main

import (
	"bufio"
	"fmt"
	"net"
	"strconv"
	"strings"
)

func NewGraphFromTCP(conn net.Conn) *Graph {
	graph := &Graph{Vertices: make(map[int]*Vertex), Communities: []*Community{}}
	scanner := bufio.NewScanner(conn)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "#") || strings.TrimSpace(line) == "" {
			continue
		}
		parts := strings.Fields(line)
		if len(parts) != 2 {
			continue
		}
		srcKey, _ := strconv.Atoi(parts[0])
		destKey, _ := strconv.Atoi(parts[1])
		graph.AddEdge(srcKey, destKey)
	}

	if err := scanner.Err(); err != nil {
		fmt.Println("Erreur de lecture du graph:", err)
	}

	return graph
}

func processGraph(graph *Graph, numWorkers int) {
	jobs := make(chan int, 2*numWorkers)
	results := make(chan bool, 2*numWorkers)
	for w := 1; w <= numWorkers; w++ {
		go worker(w, jobs, results, graph)
	}

	go createJobs(graph, jobs)

	for a := 1; a <= len(graph.Vertices); a++ {
		<-results
	}
}

func handleConnection(conn net.Conn) {
	defer conn.Close()
	graph := NewGraphFromTCP(conn)
	const numWorkers = 8
	processGraph(graph, numWorkers)
	fmt.Println("Fin Graph")
}

func main() {
	listener, err := net.Listen("tcp", ":5827")
	if err != nil {
		fmt.Println("Erreur dans le dÃ©marrage du serveur:", err)
		return
	}
	defer listener.Close()
	fmt.Println("Server is listening on port 5827...")
	for {
		conn, err := listener.Accept()
		if err != nil {
			fmt.Println("Erreur de connection tcp:", err)
			continue
		}
		go handleConnection(conn)
	}
}
